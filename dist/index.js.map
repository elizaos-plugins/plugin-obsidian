{"version":3,"sources":["../src/actions/search.ts","../src/helper.ts","../src/providers/obsidianClient.ts","../src/enviroment.ts","../src/types/index.ts","../src/actions/listNotes.ts","../src/actions/vault.ts","../src/actions/vaultDirectory.ts","../src/actions/createKnowledge.ts","../src/actions/noteTraversal.ts","../src/templates/file.ts","../src/actions/activeNote.ts","../src/templates/summary.ts","../src/actions/note.ts","../src/actions/file.ts","../src/actions/saveFile.ts","../src/actions/openFile.ts","../src/actions/updateFile.ts","../src/index.ts"],"sourcesContent":["import {\n    type Action,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    elizaLogger,\n} from \"@elizaos/core\";\nimport { getObsidian, markdownToPlaintext, processUserInput }  from \"../helper\";\nimport { isSearchQuery } from \"../types\";\n\nexport const searchAction: Action = {\n    name: \"SEARCH\",\n    similes: [\n        \"FIND\",\n        \"QUERY\",\n        \"LOOKUP\",\n        \"QUICK_SEARCH\",\n        \"BASIC_SEARCH\",\n        \"FAST_SEARCH\",\n        \"SEARCH_KEYWORD\",\n        \"OR_SEARCH\",\n        \"FIND_KEYWORDS\",\n        \"SEARCH_KEYWORDS\",\n        \"FULL_SEARCH\",\n        \"FULL_SEARCH_VAULT\",\n        \"FULL_SEARCH_NOTES\",\n        \"FULL_SEARCH_FILES\",\n        \"SEARCH_ALL\",\n        \"SEARCH_ALL_NOTES\",\n        \"SEARCH_ALL_FILES\",\n        \"SEARCH_VAULT\",\n        \"SEARCH_NOTES\",\n        \"FIND_NOTES\",\n        \"FIND_FILES\",\n        \"FIND_ALL\",\n        \"FIND_ALL_NOTES\",\n        \"FIND_ALL_FILES\",\n        \"QUERY_VAULT\",\n        \"QUERY_ALL\",\n        \"QUERY_ALL_NOTES\",\n        \"QUERY_ALL_FILES\",\n        \"DATAVIEW_QUERY\",\n        \"DQL\",\n    ],\n    description:\n        \"Search the Obsidian vault using plain text, Dataview queries, or JSONLogic. Format: 'Search QUERY' or 'Query TABLE field FROM folder'\",\n    validate: async (runtime: IAgentRuntime) => {\n        try {\n            elizaLogger.debug(\"Validating Obsidian connection\");\n            const obsidian = await getObsidian(runtime);\n            await obsidian.connect();\n            elizaLogger.debug(\"Obsidian connection validated successfully\");\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Failed to validate Obsidian connection:\", error);\n            return false;\n        }\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: any,\n        callback?: HandlerCallback\n    ) => {\n        elizaLogger.info(\"Starting search handler\");\n        const obsidian = await getObsidian(runtime);\n\n        try {\n            let query = \"\";\n            let queryFormat: 'plaintext' | 'dataview' | 'jsonlogic' = 'plaintext';\n            let searchOptions: {\n                contextLength?: number;\n                ignoreCase?: boolean;\n            } = {\n                contextLength: 150,\n                ignoreCase: true,\n            };\n\n            // Initialize or update state for context generation\n            if (!state) {\n                state = (await runtime.composeState(message)) as State;\n            } else {\n                state = await runtime.updateRecentMessageState(state);\n            }\n\n            const searchContext = await processUserInput(message.content.text as string, state, runtime);\n\n            elizaLogger.debug(\"Search context:\", JSON.stringify(searchContext.query, null, 2));\n\n            if (!isSearchQuery(searchContext)) {\n                elizaLogger.error(\n                    \"Invalid search query:\",\n                    searchContext\n                );\n                return null;\n            }\n\n            // Extract query and format from various text patterns\n            if (searchContext.queryFormat === 'dataview') {\n                query = searchContext.query;\n                queryFormat = 'dataview';\n\n                // Merge provided options with defaults\n                if (searchContext.options) {\n                    searchOptions = {\n                        ...searchOptions,\n                        ...searchContext.options as typeof searchOptions,\n                    };\n                } /*else {\n                    // Extract folders if specified in the format \"FROM folder1, folder2\"\n                    const fromMatch = query.match(/FROM\\s+\"([^\"]+)\"(?:\\s*,\\s*\"([^\"]+)\")*$/i);\n                    if (fromMatch) {\n                        searchOptions.searchIn = fromMatch\n                            .slice(1)\n                            .filter(Boolean)\n                            .map(folder => folder.trim());\n                    }\n                }*/\n\n            } else if (searchContext.queryFormat === 'jsonlogic') {\n                queryFormat = 'jsonlogic';\n                query = searchContext.query;\n                // Merge provided options with defaults\n                if (searchContext.options) {\n                    searchOptions = {\n                        ...searchOptions,\n                        ...searchContext.options as typeof searchOptions,\n                    };\n                }\n            } else {\n                query = searchContext.query;\n                // Merge provided options with defaults\n                if (searchContext.options) {\n                    searchOptions = {\n                        ...searchOptions,\n                        ...searchContext.options as typeof searchOptions,\n                    };\n                }\n            }\n\n            if (!query) {\n                throw new Error(\n                    \"Search query is required. Use format: 'Search QUERY' or 'Query TABLE field FROM folder'\"\n                );\n            }\n\n            elizaLogger.info(`Searching vault with ${queryFormat} query: ${typeof query === 'string' ? query : JSON.stringify(query)}`);\n\n            if (queryFormat === 'plaintext') {\n            const results = await obsidian.search(\n                query,\n                queryFormat,\n                searchOptions\n            );\n\n            elizaLogger.info(`Found ${results.length} matching notes`);\n\n            // Format the results into a readable string\n            const formattedResults = results.length > 0\n                ? results.map(result => {\n\n                const matches = result.matches\n                    .map(item => `${markdownToPlaintext(item.context.substring(item.match.start, searchOptions.contextLength || 150)).trim()}...`)\n                    .join('\\n');\n\nreturn `\n#### ✅ ${result.filename} (**Score:** ${result.score})\\n${matches}`;\n\n                }).join('\\n\\n')\n                : \"**No matching notes found**\";\n\n\n                elizaLogger.info(\"Formatted results:\", formattedResults);\n\n            if (callback) {\n                callback({\n                    text: `Found **${results.length}** matches:\\n\\n${formattedResults}`,\n                    metadata: {\n                        count: results.length,\n                        results: results,\n                        query: query,\n                        queryFormat: queryFormat,\n                        searchOptions: searchOptions,\n                    },\n                });\n            }\n\n        } else {\n\n            const results = await obsidian.search(\n                query,\n                queryFormat,\n                searchOptions\n            );\n\n            elizaLogger.info(`Found ${results.length} matching notes`);\n\n            // Format the results into a readable string\n            const formattedResults = results.length > 0\n                ? results.map(result => {\nreturn `\n#### ✅ ${result.filename}`;\n\n                }).join('\\n\\n')\n                : \"**No matching notes found**\";\n\n\n                elizaLogger.info(\"Formatted results:\", formattedResults);\n\n            if (callback) {\n                callback({\n                    text: `Found **${results.length}** matches:\\n\\n${formattedResults}`,\n                    metadata: {\n                        count: results.length,\n                        results: results,\n                        query: query,\n                        queryFormat: queryFormat,\n                        searchOptions: searchOptions,\n                    },\n                });\n            }\n\n\n        }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error searching vault:\", error);\n            if (callback) {\n                callback({\n                    text: `Error searching vault: ${error.message}`,\n                    error: true,\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Search project management\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"SEARCH\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Search <keyword>\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"SEARCH\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Find <keyword>\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"SEARCH\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Search project OR management\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"SEARCH\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Find meeting notes OR agenda\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"SEARCH\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Quick search todo OR task OR deadline\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"SEARCH\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"TABLE file.name FROM \\\"Notes\\\"\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"SEARCH\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"DQL FROM \\\"Daily Notes\\\" WHERE date = today\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"SEARCH\",\n                },\n            },\n        ],\n    ],\n};\n\nexport default searchAction;\n","import { type IAgentRuntime, type AgentRuntime, ModelClass, type Memory, MemoryManager, type State } from \"@elizaos/core\";\nimport { elizaLogger, composeContext, generateObject, stringToUuid } from \"@elizaos/core\";\n//import fileTypeChecker from \"file-type-checker\";\nimport { lookup } from 'mrmime';\nimport { ObsidianProvider } from \"./providers/obsidianClient\";\nimport { validateObsidianConfig } from \"./enviroment\";\nimport { searchQuerySchema, type NoteHierarchy, type NoteContent } from \"./types\";\n\n\n// Update SearchState interface to make properties optional\ninterface SearchState extends State {\n    bio: string;                  // Required from State\n    lore: string;                 // Required from State\n    messageDirections: string;    // Required from State\n    postDirections: string;       // Required from State\n    // Search-specific properties\n    query?: string | SearchQuery;\n    options?: SearchOptions;\n}\n\ninterface SearchOptions {\n    contextLength?: number;\n    searchIn?: string[];\n}\n\ninterface SearchQuery {\n    options?: {\n        searchIn?: string[];\n        contextLength?: number;\n        ignoreCase?: boolean;\n    };\n    query?: string | Record<string, unknown>;\n    queryFormat?: \"plaintext\" | \"jsonlogic\" | \"dataview\";\n    and?: Array<SearchCondition>;\n    or?: Array<SearchCondition>;\n}\n\ninterface SearchContextResponse {\n    object: SearchQuery;\n}\n\ninterface SearchCondition {\n    in?: [string, { var: string }];\n    regexp?: [string, { var: string }];\n}\n\n\nlet obsidianInstance: ObsidianProvider | undefined;\n\nexport async function getObsidian(runtime: IAgentRuntime): Promise<ObsidianProvider> {\n    if (!obsidianInstance) {\n        elizaLogger.debug(\"Creating new ObsidianProvider instance\");\n        const config = await validateObsidianConfig(runtime);\n        obsidianInstance = await ObsidianProvider.create(\n            runtime as AgentRuntime,\n            Number.parseInt(config.OBSIDIAN_API_PORT),\n            config.OBSIDIAN_API_TOKEN,\n            config.OBSIDIAN_API_URL\n        );\n    }\n    return obsidianInstance;\n}\n\n\n// Extract outgoing links from the note content\nexport function extractLinks(noteContent: NoteContent): string[] {\n    const linkRegex = /\\[\\[(.*?)\\]\\]/g;\n    const links: string[] = [];\n    let match: RegExpExecArray | null;\n    while (true) {\n        match = linkRegex.exec(noteContent.content);\n        if (match === null) break;\n        \n        if (match[1] && !lookup(match[1])) {\n            links.push(`${noteContent.path.split(\"/\")[0]}/${match[1]}.md`);\n        } else {\n            links.push(match[1]);\n        }\n    }\n    return links;\n}\n\n// Store the hierarchical link data in the AI agent's memory\nexport async function storeHierarchyInMemory(runtime: IAgentRuntime, message: Memory, hierarchy: NoteHierarchy) {\n    const memory: Memory = {\n        id: stringToUuid(hierarchy.path),\n        roomId: message.roomId,\n        userId: message.userId,\n        agentId: runtime.agentId,\n        content: {\n            text: JSON.stringify(hierarchy),\n            type: 'note_traversal',\n            metadata: {\n                path: hierarchy.path,\n                timestamp: new Date().toISOString()\n            }\n        }\n    };\n    const memoryManager = new MemoryManager({\n        runtime,\n        tableName: \"obsidian\",\n    });\n\n    await memoryManager.createMemory(memory);\n    elizaLogger.info(`Stored hierarchy for note ${hierarchy.path} in memory`);\n}\n\n// Retrieve and utilize the stored hierarchy\nexport async function retrieveHierarchyFromMemory(runtime: IAgentRuntime, message: Memory, notePath: string): Promise<NoteHierarchy | null> {\n\n    const memoryManager = new MemoryManager({\n        runtime,\n        tableName: \"obsidian\",\n    });\n\n    try {\n        const memories = await memoryManager.getMemories({\n            roomId: message.roomId,\n            count: 10,\n            start: 0,\n            end: Date.now(),\n        });\n\n        if (memories && memories.length > 0) {\n            const memory = memories[0];\n            const hierarchy: NoteHierarchy = JSON.parse(memory.content.text);\n            elizaLogger.info(`Retrieved hierarchy for note ${notePath} from memory`);\n            return hierarchy;\n        }\n        return null;\n    } catch (error) {\n        elizaLogger.error(`Failed to retrieve hierarchy from memory: ${error.message}`);\n        return null;\n    }\n}\n\n\n/**\n * Converts markdown text to plaintext by removing common markdown syntax\n *\n * This function handles the following markdown elements:\n * - Headers (# through ######)\n * - Bold and italic markers (* and _)\n * - Code blocks (both inline and multi-line)\n * - Links and images\n * - Blockquotes\n * - Horizontal rules\n * - Ordered and unordered lists\n *\n * @param markdown - The markdown text to convert\n * @returns The plaintext version of the markdown\n */\nexport function markdownToPlaintext(markdown: string): string {\n    // Handle empty or invalid input\n    if (!markdown || typeof markdown !== 'string') {\n        return '';\n    }\n\n    let text = markdown;\n\n    // Remove code blocks with their content intact\n    text = text.replace(/```[\\s\\S]*?```/g, (match) => {\n        // Remove only the backticks, preserve the code content\n        return match.slice(3, -3).trim();\n    });\n\n    // Remove inline code\n    text = text.replace(/`([^`]+)`/g, '$1');\n\n    // Remove headers while preserving content\n    text = text.replace(/^#{1,6}\\s+(.*)$/gm, '$1');\n\n    // Remove bold and italic markers\n    text = text.replace(/[*_]{1,2}([^*_]+)[*_]{1,2}/g, '$1');\n\n    // Replace horizontal rules with newlines\n    text = text.replace(/^[\\s-*_]{3,}$/gm, '\\n');\n\n    // Remove blockquotes markers\n    text = text.replace(/^>\\s+/gm, '');\n\n    // Handle links - keep text, remove URL\n    text = text.replace(/\\[([^\\]]+)\\]\\([)]+\\)/g, '$1');\n\n    // Remove image markdown completely\n    text = text.replace(/!\\[([^\\]]*)\\]\\([)]+\\)/g, '');\n\n    // Handle lists - remove markers but preserve content\n    text = text.replace(/^[\\s-]*[-+*]\\s+/gm, '');  // Unordered lists\n    text = text.replace(/^\\s*\\d+\\.\\s+/gm, '');     // Ordered lists\n\n    // Clean up excessive whitespace\n    text = text.replace(/\\n\\s*\\n\\n/g, '\\n\\n');  // Multiple blank lines to double\n    text = text.trim();\n\n    return text;\n}\n\n/**\n * Removes code block delimiters from a given string.\n * Specifically, it removes opening and closing triple backticks (```) and any language identifiers.\n *\n * @param input - The string containing code block delimiters.\n * @returns The string with code block delimiters removed.\n */\nexport function removeCodeBlockDelimiters(input: string): string {\n    // Regular expression to match opening ``` with optional language identifier and closing ```\n    const codeBlockRegex = /^```[a-zA-Z]*\\n([\\s\\S]*?)\\n```$/gm;\n\n    // Replace the matched code block delimiters with the captured content\n    return input.replace(codeBlockRegex, '$1');\n  }\n\n\n// Define example prompts to guide the LLM in generating the correct structure\nconst EXAMPLE_SEARCH_PROMPTS = [\n    {\n        input: \"Search typescript in the notes\",\n        output: {\n            query: \"typescript\",\n            queryFormat: \"plaintext\",\n            options: { contextLength: 150 }\n        }\n    },\n    {\n        input: \"Find wisdom or mastering in all files\",\n        output: {\n            query: \"wisdom OR mastering\",\n            queryFormat: \"plaintext\",\n            options: { contextLength: 150 }\n        }\n    },\n    {\n        input: \"Find markdown files containing 'react' or 'typescript'\",\n        output: {\n            query: {\n                and: [\n                    { or: [{ in: [\"react\", { var: \"content\" }] }, { in: [\"typescript\", { var: \"content\" }] }] }\n                ]\n            },\n            queryFormat: \"jsonlogic\",\n            options: { contextLength: 200 }\n        }\n    },\n    {\n        input: \"Search for files with regex pattern 'def.*main'\",\n        output: {\n            query: {\n                and: [\n                    { or: [{ regexp: [\"def.*main\", { var: \"content\" }] }] }\n                ]\n            },\n            queryFormat: \"jsonlogic\",\n            options: { contextLength: 200 }\n        }\n    },\n    {\n        input: \"Search for markdown files with regex pattern '<div[^>]*>'\",\n        output: {\n            query: {\n                and: [\n                    { or: [{ regexp: [\"<div[^>]*>\", { var: \"content\" }] }] }\n                ]\n            },\n            queryFormat: \"jsonlogic\",\n            options: { contextLength: 200 }\n        }\n    },\n    {\n        input: \"Find markdown files with filenames containing 'project'\",\n        output: {\n            query: {\n                and: [\n                    { in: [\"project\", { var: \"path\" }] }\n                ]\n            },\n            queryFormat: \"jsonlogic\",\n            options: { contextLength: 200 }\n        }\n    },\n    {\n        input: \"Search for markdown files with filenames matching regex pattern '^notes_.*\\\\.md$'\",\n        output: {\n            query: {\n                and: [\n                    { regexp: [\"^notes_.*\\\\.md$\", { var: \"path\" }] }\n                ]\n            },\n            queryFormat: \"jsonlogic\",\n            options: { contextLength: 200 }\n        }\n    },\n    {\n        input: \"Find markdown files with filenames containing 'summary' or 'report'\",\n        output: {\n            query: {\n                and: [\n                    { or: [{ in: [\"summary\", { var: \"path\" }] }, { in: [\"report\", { var: \"path\" }] }] }\n                ]\n            },\n            queryFormat: \"jsonlogic\",\n            options: { contextLength: 200 }\n        }\n    },\n    {\n        input: \"Select TABLE file.mtime FROM #Projects IN Projects/ AND Archive/Projects\",\n        output: {\n            query: \"TABLE file.mtime FROM #Projects\",\n            queryFormat: \"dataview\",\n            options: {\n                searchIn: [\"Projects/\", \"Archive/Projects/\"]\n            }\n        }\n    }\n];\n\n/**\n * Constructs a detailed prompt for the LLM to generate search parameters\n * @param userInput - The natural language search query from the user\n * @returns A formatted prompt string with examples and instructions\n */\nfunction constructSearchPrompt(userInput: string): string {\n    const examplePrompts = EXAMPLE_SEARCH_PROMPTS.map(example =>\n        `Input: \"${example.input}\"\\nOutput: ${JSON.stringify(example.output, null, 2)}`\n    ).join('\\n\\n');\n\n    return `Respond with a JSON block containing only the extracted values. Use null for any values that cannot be determined.\n\nFollow these rules:\n1. Use the exact structure shown in the examples\n2. The query is relevant to the user's request\n3. Use space-separated terms for combined search (default: 'plaintext')\n4. Use OR operator when searching for alternatives (default: 'plaintext')\n5. Always include query.and and query.or as an array (default: \"jsonlogic\")\n6. Use appropriate glob patterns for file types when appropriate (default: \"jsonlogic\")\n7. Choose between contains and regexp based on the search requirements (default: \"jsonlogic\")\n8. The format of the query - queryFormat (string): Must be one of: 'plaintext', 'dataview', or 'jsonlogic'. (default: 'plaintext')\n9. When the prompt have \"containing\" or \"contains\", use \"in\" operator. DO NOT use \"contains\" operator (this is a strictly requirement) (default: \"jsonlogic\")\n10. When the prompt have \"matching\" or \"match\", use \"regexp\" operator (default: \"jsonlogic\")\n11. Maintain contextLength at 150\n\nExamples:\n${examplePrompts}\n\nNow, convert this request:\n\"${userInput}\"\n\nRespond ONLY with a JSON block containing only the extracted values.`;\n}\n\n/**\n * Calls the LLM API to process the user's search request\n * @param prompt - The formatted prompt string\n * @returns A Promise resolving to the JSON string response\n */\n\n// Update the generateSearchParameters function\nasync function genereteSearchParameters(\n    prompt: string, \n    state: SearchState, \n    runtime: IAgentRuntime\n): Promise<string> {\n    try {\n        const context = composeContext({\n            state,\n            template: prompt,\n        });\n\n        const searchContext = await generateObject({\n            runtime,\n            context,\n            modelClass: ModelClass.MEDIUM,\n            schema: searchQuerySchema,\n            stop: [\"\\n\\n\"]\n        }) as SearchContextResponse;\n\n        // Now we can safely access .object\n        const parsedCompletion = searchContext.object;\n        elizaLogger.info(\"Parsed completion:\", JSON.stringify(parsedCompletion, null, 2));\n        return JSON.stringify(parsedCompletion);\n\n    } catch (error: unknown) {\n        console.error('Error calling LLM API:', error);\n        return \"**No matching notes found**\";\n    }\n}\n// async function genereteSearchParameters(prompt: string, state: any, runtime: IAgentRuntime): Promise<string> {\n//     try {\n\n//         const context = composeContext({\n//             state,\n//             template: prompt,\n//         });\n\n//         //TODO: temperature: 0.2 - Make this dynamic\n//         const searchContext = await generateObject({\n//             runtime,\n//             context,\n//             modelClass: ModelClass.MEDIUM,\n//             schema: searchQuerySchema,\n//             stop: [\"\\n\\n\"]\n//         }) as SearchQuery;\n\n//         /*if (!isSearchQuery(searchContext.object)) {\n//             elizaLogger.error(\n//                 \"Invalid search query:\",\n//                 searchContext.object\n//             );\n//             return null;\n//         }*/\n\n//         // Attempt to parse the completion as JSON to verify structure\n//         const parsedCompletion = searchContext.object; //JSON.parse(JSON.stringify(searchContext.object, null, 2));\n//         elizaLogger.info(\"Parsed completion:\", JSON.stringify(parsedCompletion , null, 2));\n//         return JSON.stringify(parsedCompletion);\n\n//     } catch (error) {\n//         console.error('Error calling LLM API:', error);\n//         // Return a basic fallback response that matches the schema\n//         return \"**No matching notes found**\";\n//     }\n// }\n\n// Update processUserInput to use proper types\n// export async function processUserInput(\n//     userInput: string, \n//     state: SearchState, \n//     runtime: IAgentRuntime\n// ): Promise<SearchQuery | null> {\n//     const prompt = constructSearchPrompt(userInput);\n//     const llmResponse = await genereteSearchParameters(prompt, state, runtime);\n\n//     try {\n//         const parsedResponse = JSON.parse(llmResponse) as SearchQuery;\n//         const validatedResponse = searchQuerySchema.parse(parsedResponse);\n//         return validatedResponse;\n//     } catch (error: unknown) {\n//         console.error('Failed to parse or validate LLM response:', error);\n//         return null;\n//     }\n// }\nexport async function processUserInput(\n    userInput: string, \n    state: State,  // Accept base State type\n    runtime: IAgentRuntime\n): Promise<SearchQuery | null> {\n    // Cast state to SearchState since we'll be adding search-specific properties\n    const searchState: SearchState = {\n        ...state,\n        query: userInput  // Add the query from userInput\n    };\n\n    const prompt = constructSearchPrompt(userInput);\n    const llmResponse = await genereteSearchParameters(prompt, searchState, runtime);\n\n    try {\n        const parsedResponse = JSON.parse(llmResponse) as SearchQuery;\n        const validatedResponse = searchQuerySchema.parse(parsedResponse);\n        return validatedResponse;\n    } catch (error: unknown) {\n        console.error('Failed to parse or validate LLM response:', error);\n        return null;\n    }\n}","import type { NoteContent, ResultNoteApi, ResultNoteSearchApi, ServerInfo } from \"../types\";\nimport { createHash } from \"node:crypto\";\nimport {\n    elizaLogger,\n    type AgentRuntime,\n    knowledge,\n    stringToUuid,\n} from \"@elizaos/core\";\n\nexport class ObsidianProvider {\n    private connected = false;\n    private runtime: AgentRuntime;\n    private static instance: ObsidianProvider | null = null;\n\n    private constructor(\n        private port = 27123,\n        private token: string,\n        private host_url: string\n    ) {}\n\n    /**\n     * Creates an instance of the ObsidianProvider class.\n     * @param runtime - The agent runtime.\n     * @param port - The port number to use for the Obsidian server.\n     * @param token - The authentication token for the Obsidian server.\n     * @param host_url - The URL of the Obsidian server.\n     * @returns An instance of the ObsidianProvider class.\n     */\n    static async create(\n        runtime: AgentRuntime,\n        port: number,\n        token: string,\n        host_url = `http://127.0.0.1:${port}`\n    ): Promise<ObsidianProvider> {\n        if (!this.instance) {\n            this.instance = new ObsidianProvider(port, token, host_url);\n            await this.instance.connect();\n            this.instance.runtime = runtime;\n        }\n        return this.instance;\n    }\n\n    /**\n     * Opens a file in Obsidian by its path.\n     * @param filePath - The path to the file within the vault.\n     * @returns A promise that resolves when the file is successfully opened.\n     */\n    async connect(): Promise<void> {\n        if (this.connected) return;\n\n        try {\n            const response = await fetch(`${this.host_url}/`, {\n                headers: {\n                    Authorization: `Bearer ${this.token}`,\n                },\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n\n            const serverInfo: ServerInfo = await response.json();\n\n            if (!serverInfo.authenticated) {\n                throw new Error(\"Failed to authenticate with Obsidian API\");\n            }\n\n            this.connected = true;\n        } catch (error) {\n            elizaLogger.error(\"Failed to connect to Obsidian:\", error.message);\n            this.connected = false;\n            throw error;\n        }\n    }\n\n    /**\n     * Retrieves a list of all notes within the vault.\n     * @returns A promise that resolves to an array of note paths.\n     */\n    async listNotes(): Promise<string[]> {\n        if (!this.connected) {\n            await this.connect();\n        }\n\n        try {\n            const response = await fetch(`${this.host_url}/vault/`, {\n                headers: {\n                    Authorization: `Bearer ${this.token}`,\n                    accept: \"application/json\",\n                },\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n\n            const notes: string[] = await response.json();\n            return notes;\n        } catch (error) {\n            elizaLogger.error(\"Failed to list notes:\", error.message);\n            throw error;\n        }\n    }\n\n    /**\n     * Retrieves the content of a specific note.\n     * @param path - The path to the note within the vault.\n     * @returns A promise that resolves to the content of the note.\n     */\n    async getNote(path: string): Promise<NoteContent> {\n        if (!this.connected) {\n            await this.connect();\n        }\n\n        try {\n            const response = await fetch(\n                `${this.host_url}/vault/${encodeURIComponent(\n                    path\n                )}`,\n                {\n                    headers: {\n                        Authorization: `Bearer ${this.token}`,\n                        accept: \"application/vnd.olrapi.note+json\",\n                    },\n                }\n            );\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n\n            const noteContent: NoteContent = await response.json();\n            return noteContent;\n        } catch (error) {\n            elizaLogger.error(\"Failed to fetch note content:\", error);\n            throw error;\n        }\n    }\n\n    /**\n     * Retrieves the content of the currently active note.\n     * @returns A promise that resolves to the content of the active note.\n     */\n    async getActiveNote(): Promise<NoteContent> {\n        if (!this.connected) {\n            await this.connect();\n        }\n\n        try {\n            const response = await fetch(\n                `${this.host_url}/active/`,\n                {\n                    headers: {\n                        Authorization: `Bearer ${this.token}`,\n                        accept: \"application/vnd.olrapi.note+json\",\n                    },\n                }\n            );\n\n            if (!response.ok) {\n                if (response.status === 404) {\n                    throw new Error(\"No active file found in Obsidian\");\n                }\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n\n            const noteContent: NoteContent = await response.json();\n            return noteContent;\n        } catch (error) {\n            elizaLogger.error(\"Failed to fetch active note content:\", error.message);\n            throw error;\n        }\n    }\n\n    /**\n     * Saves the content of a note to the vault.\n     * @param path - The path to the note within the vault.\n     * @param content - The content to save to the note.\n     * @param createDirectories - Whether to create directories if they don't exist.\n     * @returns A promise that resolves when the note is successfully saved.\n     */\n    async saveNote(\n        path: string,\n        content: string,\n        createDirectories = true\n    ): Promise<void> {\n        if (!this.connected) {\n            await this.connect();\n        }\n\n        try {\n            const createDirsString = createDirectories.toString();\n            const response = await fetch(\n                `${this.host_url}/vault/${encodeURIComponent(path)}`,\n                {\n                    method: \"PUT\",\n                    headers: {\n                        Authorization: `Bearer ${this.token}`,\n                        \"Content-Type\": \"text/markdown\",\n                        \"X-Create-Directories\": createDirsString,\n                    },\n                    body: content,\n                }\n            );\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n        } catch (error) {\n            elizaLogger.error(\"Failed to save note:\", error.message);\n            throw error;\n        }\n    }\n\n    /**\n     * Retrieves a list of all files within the vault.\n     * @returns A promise that resolves to an array of file paths.\n     */\n    async listFiles(): Promise<string[]> {\n        if (!this.connected) {\n            await this.connect();\n        }\n\n        try {\n            const response = await fetch(`${this.host_url}/vault/`, {\n                headers: {\n                    Authorization: `Bearer ${this.token}`,\n                    accept: \"application/json\",\n                },\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n\n            const vault: Record<string, string[]> = await response.json();\n            return vault.files as string[];\n        } catch (error) {\n            elizaLogger.error(\"Failed to list files:\", error.message);\n            throw error;\n        }\n    }\n\n    /**\n     * Retrieves a list of all files within a specific directory.\n     * @param directoryPath - The path to the directory within the vault.\n     * @returns A promise that resolves to an array of file paths.\n     */\n    async listDirectoryFiles(directoryPath: string): Promise<string[]> {\n        if (!this.connected) {\n            await this.connect();\n        }\n\n        if (directoryPath.match(/\\/$/)) {\n            directoryPath = `${directoryPath.replace(/\\/$/, \"\")}`;\n        }\n\n        try {\n            const response = await fetch(\n                `${this.host_url}/vault/${encodeURIComponent(directoryPath)}/`,\n                {\n                    headers: {\n                        Authorization: `Bearer ${this.token}`,\n                        accept: \"application/json\",\n                    },\n                }\n            );\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n\n            const vaultDirectory: Record<string, string[]> = await response.json();\n            return vaultDirectory.files as string[];\n        } catch (error) {\n            elizaLogger.error(\"Failed to list directory contents:\", error.message);\n            throw error;\n        }\n    }\n\n    /**\n     * Retrieves the content of a specific file from the vault.\n     * @param path - The path to the file within the vault.\n     * @returns A promise that resolves to the content of the file.\n     */\n    async readFile(path: string): Promise<string> {\n        if (!this.connected) {\n            await this.connect();\n        }\n\n        try {\n            const response = await fetch(\n                `${this.host_url}/vault/${encodeURIComponent(path)}`,\n                {\n                    headers: {\n                        Authorization: `Bearer ${this.token}`,\n                        accept: \"text/markdown\",\n                        \"Content-Type\": \"text/markdown\",\n                    },\n                }\n            );\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n\n            const content: string = await response.text();\n            return content;\n        } catch (error) {\n            elizaLogger.error(\"Failed to read file content:\", error.message);\n            throw error;\n        }\n    }\n\n\n    /**\n     * Opens a file in Obsidian by its path.\n     * @param filePath - The path to the file within the vault.\n     * @returns A promise that resolves when the file is successfully opened.\n     */\n    async openFile(filePath: string): Promise<void> {\n        if (!this.connected) {\n            await this.connect();\n        }\n\n        try {\n            const response = await fetch(\n                `${this.host_url}/open/${encodeURIComponent(filePath)}`,\n                {\n                    method: \"POST\",\n                    headers: {\n                        Authorization: `Bearer ${this.token}`,\n                    },\n                }\n            );\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n\n            elizaLogger.success(`Successfully opened file: ${filePath}`);\n        } catch (error) {\n            elizaLogger.error(`Failed to open file '${filePath}':`, error.message);\n            throw error;\n        }\n    }\n\n    /**\n     * Saves the content of a file to the vault.\n     * Note: Obsidian will create a new document at the path you have specified if such a document did not already exist\n     * @param path - The path to the file within the vault.\n     * @param content - The content to save to the file.\n     * @param createDirectories - Whether to create directories if they don't exist.\n     * @returns A promise that resolves when the file is successfully saved.\n     */\n    async saveFile(\n        path: string,\n        content: string,\n        createDirectories = true\n    ): Promise<void> {\n        if (!this.connected) {\n            await this.connect();\n        }\n\n        try {\n            const createDirsString = createDirectories.toString();\n            const response = await fetch(\n                `${this.host_url}/vault/${encodeURIComponent(path)}`,\n                {\n                    method: \"PUT\",\n                    headers: {\n                        Authorization: `Bearer ${this.token}`,\n                        \"Content-Type\": \"text/markdown\",\n                        \"X-Create-Directories\": createDirsString,\n                    },\n                    body: content,\n                }\n            );\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n        } catch (error) {\n            elizaLogger.error(\"Failed to save file:\", error.message);\n            throw error;\n        }\n    }\n\n    /**\n     * Inserts content into a specific section of a file.\n     * @param path - The path to the file within the vault.\n     * @param content - The content to insert into the file.\n     * @param lineNumber - The line number to insert the content at.\n     * @returns A promise that resolves when the file is successfully patched.\n     */\n    async patchFile(\n        path: string,\n        content: string,\n        lineNumber = 0\n    ): Promise<void> {\n        if (!this.connected) {\n            await this.connect();\n        }\n\n        try {\n            const response = await fetch(\n                `${this.host_url}/vault/${encodeURIComponent(path)}`,\n                {\n                    method: \"PATCH\",\n                    headers: {\n                        Authorization: `Bearer ${this.token}`,\n                        \"Content-Type\": \"application/json\",\n                    },\n                    body: JSON.stringify({ content, line: lineNumber }),\n                }\n            );\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n        } catch (error) {\n            elizaLogger.error(\"Failed to patch file content:\", error.message);\n            throw error;\n        }\n    }\n\n    /**\n     * Retrieves a list of all available Obsidian commands.\n     * @returns A promise that resolves to an array of command objects, each containing an ID and name.\n     */\n    async listCommands(): Promise<{ id: string; name: string }[]> {\n        if (!this.connected) {\n            await this.connect();\n        }\n\n        try {\n            const response = await fetch(\n                `${this.host_url}/commands/`,\n                {\n                    headers: {\n                        Authorization: `Bearer ${this.token}`,\n                        accept: \"application/json\",\n                    },\n                }\n            );\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n\n            const commands: { id: string; name: string }[] = await response.json();\n            return commands;\n        } catch (error) {\n            elizaLogger.error(\"Failed to list commands:\", error.message);\n            throw error;\n        }\n    }\n\n    /**\n     * Executes an Obsidian command by its command ID.\n     * @param commandId - The ID of the command to execute.\n     * @returns A promise that resolves when the command is successfully executed.\n     */\n    async executeCommand(commandId: string): Promise<void> {\n        if (!this.connected) {\n            await this.connect();\n        }\n\n        try {\n            const response = await fetch(\n                `${this.host_url}/commands/execute`,\n                {\n                    method: \"POST\",\n                    headers: {\n                        Authorization: `Bearer ${this.token}`,\n                        \"Content-Type\": \"application/json\",\n                    },\n                    body: JSON.stringify({ commandId }),\n                }\n            );\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n        } catch (error) {\n            elizaLogger.error(\"Failed to execute command:\", error.message);\n            throw error;\n        }\n    }\n\n    /**\n     * Searches for notes in the vault based on the provided query and options.\n     * @param query - The query to search for. Can be a string or an object.\n     * @param queryFormat - The format of the query (plaintext, dataview, or jsonlogic).\n     * @param options - Additional options for the search.\n     * @returns A promise that resolves to an array of search results.\n     */\n    async search(\n        query: string | object,\n        queryFormat: 'plaintext' | 'dataview' | 'jsonlogic' = 'plaintext',\n        options: {\n            contextLength?: number;\n            ignoreCase?: boolean;\n            isRegex?: boolean;\n            searchIn?: string[];\n        } = {}\n    ): Promise<ResultNoteApi[]|ResultNoteSearchApi[]> {\n        if (!this.connected) {\n            await this.connect();\n        }\n\n        //ignoreCase = true, isRegex = false, searchIn = []\n        const { contextLength = 100 } = options;\n\n        // Determine Content-Type and body based on queryFormat\n        let contentType: string;\n        let body: string;\n\n        switch (queryFormat) {\n            case 'dataview':\n                contentType = 'application/vnd.olrapi.dataview.dql+txt';\n                if (typeof query !== 'string') {\n                    throw new Error('Dataview query must be a string.');\n                }\n                body = query;\n                break;\n            case 'jsonlogic':\n                contentType = 'application/vnd.olrapi.jsonlogic+json';\n                if (typeof query !== 'object') {\n                    throw new Error('JsonLogic query must be an object.');\n                }\n                body = JSON.stringify(query);\n                break;\n            default:\n                contentType = 'application/json';\n                if (typeof query !== 'string') {\n                    throw new Error('Plaintext query must be a string.');\n                }\n                body = query;\n                break;\n        }\n\n        try {\n\n            elizaLogger.log(\n                `Processing search query with format ${queryFormat}:`,\n                body\n            );\n\n            if (queryFormat === 'dataview' || queryFormat === 'jsonlogic') {\n                const response = await fetch(`${this.host_url}/search`, {\n                    method: 'POST',\n                    headers: {\n                        Authorization: `Bearer ${this.token}`,\n                        'Content-Type': contentType,\n                        Accept: 'application/json',\n                    },\n                    body: body,\n                });\n\n                if (!response.ok) {\n                    throw new Error(`HTTP error! status: ${response.status}`);\n                }\n\n                const results: ResultNoteSearchApi[] = await response.json();\n                return results;\n            }\n\n            const response = await fetch(`${this.host_url}/search/simple?query=${encodeURIComponent(body)}&contextLength=${contextLength}`, {\n                method: 'POST',\n                headers: {\n                    Authorization: `Bearer ${this.token}`,\n                    'Content-Type': contentType,\n                    Accept: 'application/json',\n                }\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n\n            const results: ResultNoteApi[] = await response.json();\n            return results;\n        } catch (error) {\n            elizaLogger.error('Search failed:', error.message);\n            throw error;\n        }\n    }\n\n\n    /**\n     * Searches for notes in the vault based on the provided query and options.\n     * @param query - The query to search for. Can be a string or an object.\n     * @param queryFormat - The format of the query (plaintext, dataview, or jsonlogic).\n     * @param options - Additional options for the search.\n     * @returns A promise that resolves to an array of search results.\n     */\n    async searchKeywords(\n        query: string,\n        contextLength = 100\n    ): Promise<ResultNoteApi[]> {\n        if (!this.connected) {\n            await this.connect();\n        }\n\n        // Split on OR to get main chunks\n        const orQueries = query.split(/\\s+OR\\s+/).map((q) => q.trim());\n\n        elizaLogger.log(\n            'Processing search query with OR operator:',\n            orQueries\n        );\n\n        try {\n            const allResults: ResultNoteApi[] = [];\n\n            // Handle each OR chunk separately\n            for (const orQuery of orQueries) {\n                const response = await fetch(\n                    `${this.host_url}/search/simple/?query=${encodeURIComponent(orQuery)}&contextLength=${contextLength}`,\n                    {\n                        method: \"POST\",\n                        headers: {\n                            Authorization: `Bearer ${this.token}`,\n                            accept: \"application/json\",\n                        },\n                    }\n                );\n\n                if (!response.ok) {\n                    throw new Error(`HTTP error! status: ${response.status}`);\n                }\n\n                const results: ResultNoteApi[] = await response.json();\n                allResults.push(...results);\n            }\n\n            // Remove duplicates based on filename\n            const uniqueResults = Array.from(\n                new Map(\n                    allResults.map((item) => [item.filename, item])\n                ).values()\n            );\n\n            elizaLogger.success(`Found ${uniqueResults.length} unique results`);\n            elizaLogger.debug(\"Search results:\", uniqueResults);\n            return uniqueResults;\n        } catch (error) {\n            elizaLogger.error(\"Obsidian search failed:\", error.message);\n            throw error;\n        }\n    }\n\n\n    /**\n     * Recursively scans directories and builds a list of all files\n     * @param directory - The directory to scan, empty string for root\n     * @returns Array of file paths in format 'directory/file.md'\n     */\n    private async scanDirectoryRecursively(directory = ''): Promise<string[]> {\n        const allFiles: string[] = [];\n        const dirsToProcess: string[] = [directory];\n        const processedDirs = new Set<string>();\n\n        while (dirsToProcess.length > 0) {\n            const currentDir = dirsToProcess.shift();\n            if (currentDir === undefined) continue;\n\n            if (processedDirs.has(currentDir)) {\n                continue;\n            }\n\n            try {\n                elizaLogger.debug(\"Scanning directory:\", currentDir);\n                const items = await this.listDirectoryFiles(currentDir);\n\n                for (const item of items) {\n                    if (item.endsWith('/')) {\n                        // It's a directory, add to processing queue\n                        const fullPath = currentDir ? `${currentDir}${item}` : item;\n                        if (!processedDirs.has(fullPath)) {\n                            dirsToProcess.push(fullPath);\n                        }\n                    } else if (item.endsWith('.md')) {\n                        // It's a markdown file, add to results\n                        const filePath = currentDir ? `${currentDir}${item}` : item;\n                        allFiles.push(filePath);\n                    }\n                }\n\n                processedDirs.add(currentDir);\n            } catch (error) {\n                elizaLogger.error(`Error scanning directory ${currentDir}:`, error);\n            }\n        }\n\n        return allFiles;\n    }\n\n    /**\n     * Retrieves all files in the vault.\n     * @returns A promise that resolves to an array of file paths.\n     */\n    async getAllFiles(): Promise<string[]> {\n        if (!this.connected) {\n            await this.connect();\n        }\n\n        try {\n            elizaLogger.debug(\"Starting file scanning process\");\n\n            // Get root files and directories\n            const rootItems = await this.listFiles();\n            const allFiles: string[] = [];\n\n            // Process root level markdown files\n            const rootMdFiles = rootItems.filter(item => item.endsWith('.md'));\n            allFiles.push(...rootMdFiles);\n\n            // Process directories\n            const directories = rootItems.filter(item => item.endsWith('/'));\n            for (const dir of directories) {\n                const dirFiles = await this.scanDirectoryRecursively(dir);\n                allFiles.push(...dirFiles);\n            }\n\n            elizaLogger.info(`Completed scanning. Found ${allFiles.length} files in vault`);\n\n            // Remove any duplicates\n            const uniqueFiles = Array.from(new Set(allFiles));\n\n            return uniqueFiles;\n        } catch (error) {\n            elizaLogger.error(\"Error in getAllFiles:\", error);\n            throw error;\n        }\n    }\n\n    /**\n     * Creates memories from all files in the vault.\n     * @returns A promise that resolves to the number of memories created.\n     */\n    async createMemoriesFromFiles(): Promise<number> {\n        try {\n            elizaLogger.info(\"Starting to create memories from vault files\");\n            const allFiles = await this.getAllFiles();\n\n            elizaLogger.debug(\"All files:\", allFiles);\n            elizaLogger.success(`Found ${allFiles.length} files in vault`);\n            //return allFiles;\n\n            for (const file of allFiles) {\n                try {\n                    if (file.endsWith('.md')) {\n                        // Get the file content\n                        const content = await this.getNote(file);\n                        if (!content) {\n                            elizaLogger.warn(`No content found for file: ${file}`);\n                            continue;\n                        }\n\n                        const contentHash = createHash(\"sha256\")\n                            .update(JSON.stringify(content))\n                            .digest(\"hex\");\n\n                        const knowledgeId = stringToUuid(\n                            `obsidian-${file}`\n                        );\n\n                        const existingDocument =\n                            await this.runtime.documentsManager.getMemoryById(knowledgeId);\n\n                        if (\n                            existingDocument &&\n                            existingDocument.content.hash === contentHash\n                        ) {\n                            elizaLogger.debug(`Skipping unchanged file: ${file}`);\n                            continue;\n                        }\n\n                        elizaLogger.info(\n                            `Processing knowledge for ${this.runtime.character.name} - ${file}`\n                        );\n\n                        await knowledge.set(this.runtime, {\n                            id: knowledgeId,\n                            content: {\n                                text: content.content,\n                                hash: contentHash,\n                                source: \"obsidian\",\n                                attachments: [],\n                                metadata: {\n                                    path: file,\n                                    tags: content.tags,\n                                    frontmatter: content.frontmatter,\n                                    stats: content.stat\n                                },\n                            },\n                        });\n\n                        // delay to avoid throttling\n                        await new Promise(resolve => setTimeout(resolve, 100));\n                    }\n                } catch (error) {\n                    elizaLogger.error(`Error processing file ${file}:`, error);\n                    // continue;\n                }\n            }\n\n            elizaLogger.success(\"Finished creating memories from vault notes\");\n\n            return allFiles.length;\n\n        } catch (error) {\n            elizaLogger.error(\"Error in createMemoriesFromFiles:\", error);\n            return 0;\n        }\n    }\n\n    /**\n     * Checks if the client is connected to Obsidian.\n     * @returns `true` if the client is connected, `false` otherwise.\n     */\n    isConnected(): boolean {\n        return this.connected;\n    }\n\n    /**\n     * Closes the connection to Obsidian.\n     */\n    close() {\n        this.connected = false;\n        ObsidianProvider.instance = null;\n    }\n}\n","import type { IAgentRuntime } from \"@elizaos/core\";\nimport { z } from \"zod\";\n\nexport const obsidianEnvSchema = z\n    .object({\n        OBSIDIAN_API_URL: z.string().nullable().optional(),\n        OBSIDIAN_API_PORT: z.string().default(\"27123\"),\n        OBSIDIAN_API_TOKEN: z.string(),\n    })\n    .refine((data) => !!data.OBSIDIAN_API_TOKEN, {\n        message: \"OBSIDIAN_API_TOKEN is required\",\n    });\n\nexport type ObsidianConfig = z.infer<typeof obsidianEnvSchema>;\n\nexport async function validateObsidianConfig(\n    runtime: IAgentRuntime\n): Promise<ObsidianConfig> {\n    try {\n        const config = {\n            OBSIDIAN_API_URL:\n                runtime.getSetting(\"OBSIDIAN_API_URL\") ||\n                process.env.OBSIDIAN_API_URL ||\n                null,\n            OBSIDIAN_API_PORT:\n                runtime.getSetting(\"OBSIDIAN_API_PORT\") ||\n                process.env.OBSIDIAN_API_PORT ||\n                \"27123\",\n            OBSIDIAN_API_TOKEN:\n                runtime.getSetting(\"OBSIDIAN_API_TOKEN\") ||\n                process.env.OBSIDIAN_API_TOKEN,\n        };\n\n        return obsidianEnvSchema.parse(config);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `Obsidian configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n","import { z } from \"zod\";\n\nexport interface SearchMatchApi {\n    match: {\n        start: number;\n        end: number;\n    };\n    context: string;\n}\n\nexport const noteSchema = z.object({\n    tags: z.array(z.string()).optional(),\n    frontmatter: z.record(z.unknown()).optional(),\n    stat: z.object({\n        ctime: z.number(),\n        mtime: z.number(),\n        size: z.number(),\n    }).nullable().optional(),\n    path: z.string(),\n    content: z.string().nullable().optional(),\n});\n\nexport type NoteContent = z.infer<typeof noteSchema>;\n\nexport const isValidNote = (note: unknown): note is NoteContent => {\n    return noteSchema.safeParse(note).success;\n};\n\nexport const fileSchema = z.object({\n    path: z.string(),\n    content: z.string().nullable().optional(),\n    stat: z.object({\n        ctime: z.number(),\n        mtime: z.number(),\n        size: z.number(),\n    }).nullable().optional()\n});\n\nexport type FileContent = z.infer<typeof fileSchema>;\n\nexport const isValidFile = (file: unknown): file is FileContent => {\n    return fileSchema.safeParse(file).success;\n};\n\nexport interface ResultNoteApi {\n    filename: string;\n    matches: SearchMatchApi[];\n    score: number;\n}\n\nexport interface ResultNoteSearchApi {\n    filename: string;\n    result: boolean;\n}\n\nexport interface ServerInfo {\n    authenticated: boolean;\n    ok: boolean;\n    service: string;\n    versions: {\n        obsidian: string;\n        self: string;\n    };\n}\n\nexport interface Command {\n    id: string;\n    name: string;\n}\n\nexport interface PatchContent {\n    content: string;\n    line: number;\n}\n\n/*\nexport interface NoteHierarchy {\n    path: string;\n    content: string;\n    links: NoteHierarchy[];\n}\n*/\n\nexport const noteHierarchySchema = z.object({\n    path: z.string(),\n    content: z.string().nullable().optional(),\n    links: z.lazy(() => z.array(noteHierarchySchema)).nullable().optional()\n});\n\nexport type NoteHierarchy = z.infer<typeof noteHierarchySchema>;\n\nexport const isValidNoteHierarchy = (hierarchy: unknown): hierarchy is NoteHierarchy => {\n    return noteHierarchySchema.safeParse(hierarchy).success;\n};\n\nexport const searchKeywordSchema = z.object({\n    query: z.string().min(1).describe(\"The keywords to search for\"),\n    options: z\n        .object({\n            vault: z.string().optional(),\n            includeExcerpt: z.boolean().optional(),\n            limit: z.number().optional(),\n        })\n        .optional(),\n});\n\nexport type SearchKeyword = z.infer<typeof searchKeywordSchema>;\n\nexport function isSearchKeyword(obj: any): obj is SearchKeyword {\n    return searchKeywordSchema.safeParse(obj).success;\n}\n\nexport type QueryFormat = 'plaintext' | 'dataview' | 'jsonlogic';\n\nexport interface SearchOptions {\n    contextLength?: number;\n    ignoreCase?: boolean;\n    searchIn?: string[] | null;\n}\n\nexport interface SearchQuery {\n    query?: string;\n    queryFormat?: QueryFormat;\n    options?: SearchOptions;\n}\n\nexport const searchOptionsSchema = z.object({\n    contextLength: z.number().optional(),\n    ignoreCase: z.boolean().nullable().optional().default(true),\n    searchIn: z.array(z.string()).nullable().optional().default([]),\n});\n\nexport const searchQuerySchema = z.object({\n    query: z.union([z.string(), z.record(z.unknown())]).describe(\"The query to search for\"),\n    queryFormat: z.enum(['plaintext', 'dataview', 'jsonlogic']).describe(\"The format of the query\"),\n    options: searchOptionsSchema.optional().describe(\"Search options\"),\n});\n\nexport const isSearchQuery = (obj: unknown): obj is SearchQuery => {\n    return searchQuerySchema.safeParse(obj).success;\n};\n","import {\n    type Action,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    elizaLogger,\n} from \"@elizaos/core\";\nimport { getObsidian }  from \"../helper\";\n\nexport const listNotesAction: Action = {\n    name: \"LIST_NOTES\",\n    similes: [\n        \"LIST_NOTES\",\n        \"SHOW_NOTES\",\n        \"GET_NOTES\",\n        \"FETCH_NOTES\",\n        \"VIEW_NOTES\",\n        \"DISPLAY_NOTES\",\n        \"ENUMERATE_NOTES\",\n    ],\n    description:\n        \"List all markdown notes in the Obsidian vault. Use format: 'List notes' or 'Show all notes'\",\n    validate: async (runtime: IAgentRuntime) => {\n        try {\n            elizaLogger.debug(\"Validating Obsidian connection\");\n            const obsidian = await getObsidian(runtime);\n            await obsidian.connect();\n            elizaLogger.debug(\"Obsidian connection validated successfully\");\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Failed to validate Obsidian connection:\", error);\n            return false;\n        }\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        _message: Memory,\n        _state: State,\n        _options: any,\n        callback?: HandlerCallback\n    ) => {\n        elizaLogger.info(\"Starting list notes handler\");\n        const obsidian = await getObsidian(runtime);\n\n        try {\n            elizaLogger.info(\"Fetching list of notes from vault\");\n            const notes: string[] = await obsidian.listNotes();\n\n            elizaLogger.info(`Successfully retrieved ${notes.length} notes`);\n\n            // Format the notes list into a readable string\n            const formattedNotes = notes.length > 0\n                ? notes.map(note => `- ${note}`).join('\\n')\n                : \"No notes found in the vault\";\n\n            if (callback) {\n                callback({\n                    text: `Found ${notes.length} notes in the vault:\\n\\n${formattedNotes}`,\n                    metadata: {\n                        count: notes.length,\n                        notes: notes,\n                    },\n                });\n            }\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error listing notes:\", error);\n            if (callback) {\n                callback({\n                    text: `Error listing notes: ${error.message}`,\n                    error: true,\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"List notes\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"LIST_NOTES\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Show all notes in vault\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"LIST_NOTES\",\n                },\n            },\n        ],\n    ],\n};\n","import {\n    type Action,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    elizaLogger,\n} from \"@elizaos/core\";\nimport { getObsidian }  from \"../helper\";\n\nexport const listAllFilesAction: Action = {\n    name: \"LIST_ALL\",\n    similes: [\n        \"LIST_VAULT_FILES\",\n        \"LIST_ALL_VAULT_FILES\",\n        \"LIST_ALL_FILES\",\n        \"SHOW_ALL_FILES\",\n        \"GET_ALL_FILES\",\n        \"FETCH_ALL_FILES\",\n        \"VIEW_ALL_FILES\",\n        \"DISPLAY_ALL_FILES\",\n        \"ENUMERATE_ALL_FILES\",\n        \"LIST_EVERYTHING\",\n        \"SHOW_EVERYTHING\"\n    ],\n    description:\n        \"List all files in the entire Obsidian vault. Use format: 'List all files' or 'Show all files'\",\n    validate: async (runtime: IAgentRuntime) => {\n        try {\n            elizaLogger.debug(\"Validating Obsidian connection\");\n            const obsidian = await getObsidian(runtime);\n            await obsidian.connect();\n            elizaLogger.debug(\"Obsidian connection validated successfully\");\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Failed to validate Obsidian connection:\", error);\n            return false;\n        }\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        _message: Memory,\n        _state: State,\n        _options: any,\n        callback?: HandlerCallback\n    ) => {\n        elizaLogger.info(\"Starting list all files handler\");\n        const obsidian = await getObsidian(runtime);\n\n        try {\n            elizaLogger.info(\"Fetching list of all files from vault\");\n\n            const files: string[] = await obsidian.listFiles();\n            elizaLogger.info(`Successfully retrieved ${files.length} files`);\n\n            // Group files by directory for better organization\n            const filesByDirectory: { [key: string]: string[] } = {};\n\n            for (const file of files) {\n                const directory = file.split('/').slice(0, -1).join('/') || '/';\n                if (!filesByDirectory[directory]) {\n                    filesByDirectory[directory] = [];\n                }\n                filesByDirectory[directory].push(file.split('/').pop() || file);\n            }\n\n\n            // Format the files list into a readable tree structure\n            const formattedFiles = files.length > 0\n                ? Object.entries(filesByDirectory)\n                    .map(([directory, files]) =>\n                        `${directory === '/' ? 'Root' : directory}:\\n${files.map(file => `  - ${file}`).join('\\n')}`)\n                    .join('\\n\\n')\n                : \"No files found in the vault\";\n\n            if (callback) {\n                callback({\n                    text: `Found ${files.length} files in the vault:\\n\\n${formattedFiles}`,\n                    metadata: {\n                        count: files.length,\n                        files: files,\n                        filesByDirectory: filesByDirectory,\n                    },\n                });\n            }\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error listing files:\", error);\n            if (callback) {\n                callback({\n                    text: `Error listing files: ${error.message}`,\n                    error: true,\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"List all files\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"LIST_ALL\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Show everything in the vault\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"LIST_ALL\",\n                },\n            },\n        ],\n    ],\n};\n","import {\n    type Action,\n    type HandlerCallback,\n    type AgentRuntime as IAgentRuntime,\n    type Memory,\n    type State,\n    elizaLogger,\n} from \"@elizaos/core\";\nimport { getObsidian }  from \"../helper\";\n\nexport const listDirectoryAction: Action = {\n    name: \"LIST_DIRECTORY\",\n    similes: [\n        \"SHOW_DIRECTORY\",\n        \"LIST_FOLDER\",\n        \"SHOW_FOLDER\",\n        \"VIEW_DIRECTORY\",\n        \"VIEW_FOLDER\",\n        \"LIST_DIR\",\n        \"SHOW_DIR\",\n        \"DIR\",\n        \"LS\",\n    ],\n    description:\n        \"List all files in a specific directory of the Obsidian vault. Use format: 'List directory PATH' or 'Show files in PATH'\",\n    validate: async (runtime: IAgentRuntime) => {\n        try {\n            elizaLogger.debug(\"Validating Obsidian connection\");\n            const obsidian = await getObsidian(runtime);\n            await obsidian.connect();\n            elizaLogger.debug(\"Obsidian connection validated successfully\");\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Failed to validate Obsidian connection:\", error);\n            return false;\n        }\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        _state: State,\n        _options: any,\n        callback?: HandlerCallback\n    ) => {\n        elizaLogger.info(\"Starting list directory handler\");\n        const obsidian = await getObsidian(runtime);\n\n        try {\n            let directoryPath = \"\";\n            const text = message.content.text;\n\n            // Extract directory path from various text formats\n            if (text) {\n                const patterns = [\n                    /^(?:List|Show|View)\\s+(?:directory|folder|files in|dir)\\s+(.+)$/i,\n                    /^(?:List|Show|View)\\s+(.+)\\s+(?:directory|folder|files)$/i,\n                    /^(?:ls|dir)\\s+(.+)$/i\n                ];\n\n                for (const pattern of patterns) {\n                    const match = text.match(pattern);\n                    if (match) {\n                        directoryPath = match[1].trim();\n                        break;\n                    }\n                }\n            }\n\n            // Fallback to explicit path if provided\n            if (!directoryPath && message.content.path) {\n                directoryPath = message.content.path as string;\n            }\n\n            if (!directoryPath) {\n                throw new Error(\n                    \"Directory path is required. Use format: 'List directory PATH' or 'Show files in PATH'\"\n                );\n            }\n\n            elizaLogger.info(`Listing files in directory: ${directoryPath}`);\n            const files: string[] = await obsidian.listDirectoryFiles(directoryPath);\n            elizaLogger.info(`Successfully retrieved ${files.length} files`);\n\n            // Format the files list into a readable string\n            const formattedFiles = files.length > 0\n                ? files.map(file => `- ${file}`).join('\\n')\n                : \"No files found in the directory\";\n\n            if (callback) {\n                callback({\n                    text: `Found ${files.length} files in ${directoryPath}:\\n\\n${formattedFiles}`,\n                    metadata: {\n                        directory: directoryPath,\n                        count: files.length,\n                        files: files,\n                    },\n                });\n            }\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error listing directory:\", error);\n            if (callback) {\n                callback({\n                    text: `Error listing directory: ${error.message}`,\n                    error: true,\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"List directory BLOG POSTS\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"LIST_DIRECTORY\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Show files in PROJECTS/src\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"LIST_DIRECTORY\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"ls DOCUMENTS/research\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"LIST_DIRECTORY\",\n                },\n            },\n        ],\n    ],\n};\n","import {\n    type Action,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    elizaLogger,\n} from \"@elizaos/core\";\nimport { getObsidian }  from \"../helper\";\n\nexport const createKnowledgeAction: Action = {\n    name: \"CREATE_KNOWLEDGE\",\n    similes: [\n        \"BUILD_KNOWLEDGE\",\n        \"CREATE_KNOWLEDGE_BASE\",\n        \"CREATE_KNOWLEDGE_BASE\",\n        \"BUILD_KNOWLEDGE_BASE\"\n    ],\n    description:\n        \"Scan all markdown notes hierarchically in the Obsidian vault and build a memoryknowledge base. Use format: 'Create knowledge' or 'Build knowledge base'\",\n    validate: async (runtime: IAgentRuntime) => {\n        try {\n            elizaLogger.debug(\"Validating Obsidian connection\");\n            const obsidian = await getObsidian(runtime);\n            await obsidian.connect();\n            elizaLogger.debug(\"Obsidian connection validated successfully\");\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Failed to validate Obsidian connection:\", error);\n            return false;\n        }\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        _message: Memory,\n        _state: State,\n        _options: any,\n        callback?: HandlerCallback\n    ) => {\n        elizaLogger.info(\"Starting create knowledge handler\");\n        const obsidian = await getObsidian(runtime);\n\n        try {\n            elizaLogger.info(\"Fetching all notes from vault and creating knowledge base\");\n            elizaLogger.log(\"Be patient, this might take a while, depending on the size of your vault...\");\n            if (callback) {\n                callback({\n                    text: \"This might take a while, depending on the size of your vault...\",\n                    error: false,\n                });\n            }\n            try {\n                const notesMemorized = await obsidian.createMemoriesFromFiles();\n\n                if (callback) {\n                    callback({\n                        text: `Finished creating knowledge base for ${notesMemorized ?? 0} notes in the vault`,\n                        metadata: {\n                            count: notesMemorized ?? 0,\n                        },\n                    });\n                }\n\n            } catch (error) {\n                elizaLogger.error(\"Error creating knowledge memories from notes:\", error);\n                if (callback) {\n                    callback({\n                        text: `Error creating knowledge memories from notes: ${error.message}`,\n                        error: true,\n                    });\n                }\n                return false;\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error creating knowledge base:\", error);\n            if (callback) {\n                callback({\n                    text: `Error creating knowledge base: ${error.message}`,\n                    error: true,\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Create knowledge\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"CREATE_KNOWLEDGE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Build knowledge base\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"CREATE_KNOWLEDGE\",\n                },\n            },\n        ],\n    ],\n};\n","import {\n    type Action,\n    type HandlerCallback,\n    type AgentRuntime as IAgentRuntime,\n    type Memory,\n    type State,\n    elizaLogger,\n    composeContext,\n    generateObject,\n    ModelClass\n} from \"@elizaos/core\";\nimport { type NoteContent, type NoteHierarchy, isValidNoteHierarchy, noteHierarchySchema } from \"../types\";\nimport { getObsidian, extractLinks, storeHierarchyInMemory, retrieveHierarchyFromMemory } from \"../helper\";\nimport { traversalTemplate } from \"../templates/traversal\";\nimport { fileTemplate } from \"../templates/file\";\n\nexport const noteTraversalAction: Action = {\n    name: \"TRAVERSE_NOTE\",\n    similes: [\n        \"MAP_NOTE_LINKS\",\n        \"MAP_LINKS_IN\",\n        \"GET_NOTE_HIERARCHY\",\n        \"SHOW_NOTE_LINKS\",\n        \"LIST_NOTE_CONNECTIONS\",\n        \"DISPLAY_NOTE_NETWORK\",\n        \"EXPLORE_NOTE_LINKS\",\n        \"VIEW_NOTE_CONNECTIONS\",\n        \"ANALYZE_NOTE_LINKS\",\n    ],\n    description:\n        \"Generate a hierarchical list of all outgoing links from a specific note, including nested links. Use format: 'Map links in FOLDER/Note.md'\",\n    validate: async (runtime: IAgentRuntime) => {\n        try {\n            elizaLogger.debug(\"Validating Obsidian connection\");\n            const obsidian = await getObsidian(runtime);\n            await obsidian.connect();\n            elizaLogger.debug(\"Obsidian connection validated successfully\");\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Failed to validate Obsidian connection:\", error);\n            return false;\n        }\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: any,\n        callback?: HandlerCallback\n    ) => {\n        elizaLogger.info(\"Starting note traversal handler\");\n        const obsidian = await getObsidian(runtime);\n\n        try {\n            let path = \"\";\n            /*const text = message.content.text;\n\n            // Extract path from text like \"Map links in FOLDER/Note.md\"\n            if (text) {\n                const match = text.match(/^(?:Map links in\\s+)?(.+\\.md)$/i);\n                if (match) {\n                    path = match[1];\n                }\n            }*/\n\n            // Initialize or update state for context generation\n            // if (!state) {\n            //     state = (await runtime.composeState(message)) as State;\n            // } else {\n            //     state = await runtime.updateRecentMessageState(state);\n            // }\n\n            let currentState: State;\n            if (!state) {\n                currentState = (await runtime.composeState(message)) as State;\n            } else {\n                currentState = await runtime.updateRecentMessageState(state);\n            }\n\n            const context = composeContext({\n                state: currentState,\n                template: fileTemplate(message.content.text),\n            });\n\n            const noteContext = await generateObject({\n                runtime,\n                context,\n                modelClass: ModelClass.MEDIUM,\n                schema: noteHierarchySchema,\n                stop: [\"\\n\"]\n            }) as any;\n\n            if (!isValidNoteHierarchy(noteContext.object)) {\n                elizaLogger.error(\n                    \"Note path is required. Use format: 'Map links in FOLDER/Note.md' - \",\n                    noteContext.object\n                );\n\n                if (callback) {\n                    callback({\n                        text: `Note path is required. Use format: 'Map links in FOLDER/Note.md' - ${noteContext.object}`,\n                        error: true,\n                    });\n                }\n\n                return false;\n            }\n\n            // Extract path from context\n            path = noteContext.object.path;\n\n            // Fallback to explicit path if provided\n            if (!path && message.content.path) {\n                path = message.content.path as string;\n            }\n\n            if (!path) {\n                throw new Error(\n                    \"Note path is required. Use format: 'Map links in FOLDER/Note.md'\"\n                );\n            }\n\n            // Try to retrieve from memory first\n            const cachedHierarchy = await retrieveHierarchyFromMemory(runtime, message, path);\n            if (cachedHierarchy) {\n                elizaLogger.info(`Using cached hierarchy for note: ${path}`);\n                if (callback) {\n                    callback({\n                        text: formatHierarchy(cachedHierarchy),\n                        metadata: {\n                            path: path,\n                            hierarchy: cachedHierarchy,\n                            source: 'cache'\n                        },\n                    });\n                }\n                return true;\n            }\n\n            // Implement recursive function to build the hierarchy\n            async function buildLinkHierarchy(notePath: string, depth = 0, visited = new Set<string>()): Promise<NoteHierarchy | null> {\n                // Prevent infinite recursion by checking if we've visited this note\n                if (visited.has(notePath)) {\n                    return null;\n                }\n                visited.add(notePath);\n\n                try {\n                    const noteContent: NoteContent = await obsidian.getNote(notePath);\n                    const links = extractLinks(noteContent);\n                    const hierarchy: NoteHierarchy = {\n                        path: notePath,\n                        content: noteContent.content,\n                        links: []\n                    };\n\n                    // Limit recursion depth to prevent excessive traversal\n                    if (depth < 7) {\n                        for (const link of links) {\n                            const childHierarchy = await buildLinkHierarchy(link, depth + 1, visited);\n                            if (childHierarchy) {\n                                hierarchy.links.push(childHierarchy);\n                            }\n                        }\n                    }\n\n                    return hierarchy;\n                } catch (error) {\n                    elizaLogger.error(`Failed to process note ${notePath}: ${error.message}`);\n                    return null;\n                }\n            }\n\n            elizaLogger.info(`Building link hierarchy for note: ${path}`);\n            const hierarchy = await buildLinkHierarchy(path);\n\n            if (!hierarchy) {\n                throw new Error(`Failed to build hierarchy for note: ${path}`);\n            }\n\n            // Store the hierarchy in memory for future use\n            await storeHierarchyInMemory(runtime, message, hierarchy);\n\n            // Format the hierarchy for display\n            function formatHierarchy(node: NoteHierarchy, level = 0): string {\n                const indent = \"  \".repeat(level);\n                let result = `${indent}- ${node.path}\\n`;\n\n                elizaLogger.info(`Node hierarchy links for note: ${node.links}`);\n\n                for (const link of node.links as NoteHierarchy[]) {\n                    result += formatHierarchy(link, level + 1);\n                }\n                return result;\n            }\n\n            const formattedHierarchy = formatHierarchy(hierarchy);\n            elizaLogger.info(`Successfully built hierarchy for note: ${path}`);\n\n            if (callback) {\n                callback({\n                    text: formattedHierarchy,\n                    metadata: {\n                        path: path,\n                        hierarchy: hierarchy,\n                        source: 'obsidian'\n                    },\n                });\n            }\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error in note traversal:\", error);\n            if (callback) {\n                callback({\n                    text: `Error in note traversal: ${error.message}`,\n                    error: true,\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Show outgoing links in Knowledge Base/Main Index.md\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"TRAVERSE_NOTE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Map links in Knowledge Base/Main Index.md\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"TRAVERSE_NOTE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Show note connections in Projects/Project Overview.md\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"TRAVERSE_NOTE\",\n                },\n            },\n        ],\n    ],\n};\n","export const fileTemplate = (userRequest: string) => `\nRespond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n\nEnsure that:\n1. The path is properly formatted with correct folder structure\n2. The operation matches one of the supported actions (Default: READ)\n3. Content is provided when required for write operations\n4. Path uses forward slashes (/) as separators\n5. Make sure to remove \\`\\`\\`json and \\`\\`\\` from the response\n\nProvide the details in the following JSON format:\n\n\\`\\`\\`json\n{\n    \"path\": \"<folder>/<subfolder>/<filename>\",\n    \"operation\": \"<READ|WRITE>\",\n    \"content\": \"<file_content_to_write>\"\n}\n\\`\\`\\`\n\nHere are the recent user messages for context:\n${userRequest}\n\nRespond ONLY with a JSON markdown block containing only the extracted values.`;\n\n","import {\n    type Action,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    elizaLogger,\n    composeContext,\n    ModelClass,\n    splitChunks,\n    trimTokens,\n    generateText,\n} from \"@elizaos/core\";\nimport type { NoteContent } from \"../types\";\nimport { baseSummaryTemplate } from \"../templates/summary\";\nimport { getObsidian }  from \"../helper\";\n\nexport const getActiveNoteAction: Action = {\n    name: \"GET_ACTIVE_NOTE\",\n    similes: [\n        \"FETCH_ACTIVE_NOTE\",\n        \"READ_ACTIVE_NOTE\",\n        \"CURRENT_NOTE\",\n        \"ACTIVE_NOTE\",\n        \"OPENED_NOTE\",\n        \"CURRENT_FILE\",\n    ],\n    description:\n        \"Retrieve and display the content of the currently active note in Obsidian\",\n    validate: async (runtime: IAgentRuntime) => {\n        try {\n            const obsidian = await getObsidian(runtime);\n            await obsidian.connect();\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Failed to validate Obsidian connection:\", error);\n            return false;\n        }\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        _message: Memory,\n        _state: State,\n        _options: any,\n        callback?: HandlerCallback\n    ) => {\n        elizaLogger.info(\"Starting get active note handler\");\n        const obsidian = await getObsidian(runtime);\n\n        try {\n            elizaLogger.info(\"Fetching active note content\");\n            const noteContent: NoteContent = await obsidian.getActiveNote();\n\n            elizaLogger.info(\n                `Successfully retrieved active note: ${noteContent.path}`\n            );\n\n            if (callback) {\n                callback({\n                    text: noteContent.content,\n                    metadata: {\n                        path: noteContent.path,\n                    },\n                });\n            }\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error getting active note:\", error);\n            if (callback) {\n                callback({\n                    text: `Error retrieving active note: ${error.message}`,\n                    error: true,\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What's in my current note?\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"GET_ACTIVE_NOTE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Show me the active note\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"GET_ACTIVE_NOTE\",\n                },\n            },\n        ],\n    ],\n};\n\nexport const summarizeActiveNoteAction: Action = {\n    name: \"SUMMARIZE_ACTIVE_NOTE\",\n    similes: [\n        \"SUMMARIZE_ACTIVE_NOTE\",\n        \"SUMMARIZE_CURRENT_NOTE\",\n        \"SUMMARIZE_OPEN_NOTE\",\n    ],\n    description:\n        \"Generate a focused summary of the currently active note in Obsidian\",\n    validate: async (runtime: IAgentRuntime) => {\n        try {\n            elizaLogger.debug(\"Validating Obsidian connection\");\n            const obsidian = await getObsidian(runtime);\n            await obsidian.connect();\n            elizaLogger.debug(\"Obsidian connection validated successfully\");\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Failed to validate Obsidian connection:\", error);\n            return false;\n        }\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: any,\n        callback?: HandlerCallback\n    ) => {\n        elizaLogger.info(\"Starting summarize active note handler\");\n        const obsidian = await getObsidian(runtime);\n\n        try {\n            elizaLogger.info(\"Fetching active note content\");\n            const noteContent: NoteContent = await obsidian.getActiveNote();\n\n            if (!state) {\n                state = (await runtime.composeState(message)) as State;\n            } else {\n                state = await runtime.updateRecentMessageState(state);\n            }\n            const chunkSize = 6500;\n\n            const chunks = await splitChunks(noteContent.content, chunkSize, 0);\n            let currentSummary = \"\";\n\n            elizaLogger.info(\"Composing summary context\");\n            for (let i = 0; i < chunks.length; i++) {\n                const chunk = chunks[i];\n                state.currentSummary = currentSummary;\n                state.currentChunk = chunk;\n\n                const activeNoteTemplate = await trimTokens(\n                    baseSummaryTemplate,\n                    chunkSize,\n                    runtime\n                );\n\n                const context = composeContext({\n                    state,\n                    template: activeNoteTemplate,\n                });\n                const summary = await generateText({\n                    runtime,\n                    context,\n                    modelClass: ModelClass.MEDIUM,\n                });\n\n                currentSummary = `${currentSummary}\\n${summary}`;\n            }\n            if (!currentSummary) {\n                elizaLogger.error(\"Error: No summary found\");\n                return false;\n            }\n            if (callback) {\n                if (\n                    currentSummary.trim()?.split(\"\\n\").length < 4 ||\n                    currentSummary.trim()?.split(\" \").length < 100\n                ) {\n                    callback({\n                        text: `Here is the summary:\\n\\`\\`\\`md\\n${currentSummary.trim()}\\n\\`\\`\\``,\n                        metadata: {\n                            path: noteContent.path,\n                        },\n                    });\n                } else {\n                    callback({\n                        text: currentSummary.trim(),\n                        metadata: {\n                            path: noteContent.path,\n                        },\n                    });\n                }\n            }\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error summarizing active note:\", error);\n            if (callback) {\n                callback({\n                    text: `Error summarizing active note: ${error.message}`,\n                    error: true,\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Summarize my current note\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"SUMMARIZE_ACTIVE_NOTE\",\n                },\n            },\n        ],\n    ],\n};\n","export const summaryTemplate = `\nExtract a focused summary of the provided Obsidian note content based on the following:\n- **theme** (string): The main topic or theme to focus the summary around\n- **content** (string): The full markdown content to be summarized\n\nEnsure that:\n1. The summary is relevant to the specified theme/topic\n2. Key points and insights related to the theme are highlighted\n3. The summary maintains proper context from the original content\n4. Important quotes or examples related to the theme are preserved\n5. The summary length is proportional to the content's relevance to the theme\n6. Make sure to remove \\`\\`\\`json and \\`\\`\\` from the response\n\nProvide the summary in the following JSON format:\n\n\\`\\`\\`json\n{\n    \"theme\": \"<theme>\",\n    \"summary\": \"<focused_summary>\",\n    \"relevance\": \"<high|medium|low>\",\n    \"key_points\": [\n        \"<point_1>\",\n        \"<point_2>\"\n    ],\n    \"related_quotes\": [\n        \"<quote_1>\",\n        \"<quote_2>\"\n    ]\n}\n\\`\\`\\`\n\nHere are the recent user messages and note content for context:\n{{recentMessages}}\n\nNote content to summarize:\n{{responseData}}\n`;\n\nexport const baseSummaryTemplate = `# Summarized so far (we are adding to this)\n{{currentSummary}}\n\n# Current note chunk we are summarizing (includes metadata)\n{{currentChunk}}\n\nSummarization objective: {{objective}}\n\n# Instructions: Summarize the note content so far. Return the summary. Do not acknowledge this request, just summarize and continue the existing summary if there is one. Capture any important details to the objective. Only respond with the new summary text.\nYour response should be extremely detailed and include any and all relevant information.`;\n","import {\n    type Action,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    elizaLogger,\n    composeContext,\n    generateObject,\n    ModelClass\n} from \"@elizaos/core\";\nimport { type NoteContent, noteSchema, isValidNote } from \"../types\";\nimport { getObsidian }  from \"../helper\";\nimport { noteTemplate } from \"../templates/note\";\nimport { fileTemplate } from \"../templates/file\";\n\nexport const getNoteAction: Action = {\n    name: \"GET_NOTE\",\n    similes: [\n        \"DISPLAY_NOTE\",\n        \"GRAB_NOTE\",\n        \"FETCH_NOTE\",\n        \"READ_NOTE\",\n        \"RETRIEVE_NOTE\",\n        \"LOAD_NOTE\",\n        \"OPEN_NOTE\",\n        \"ACCESS_NOTE\",\n        \"VIEW_NOTE\",\n        \"SHOW_NOTE\"\n    ],\n    description:\n        \"Retrieve and display the content of a specific note from Obsidian vault by path. Use format: 'Get FOLDER/SUBFOLDER/Note Name.md'\",\n    validate: async (runtime: IAgentRuntime) => {\n        try {\n            elizaLogger.debug(\"Validating Obsidian connection\");\n            const obsidian = await getObsidian(runtime);\n            await obsidian.connect();\n            elizaLogger.debug(\"Obsidian connection validated successfully\");\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Failed to validate Obsidian connection:\", error);\n            return false;\n        }\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: any,\n        callback?: HandlerCallback\n    ) => {\n        elizaLogger.info(\"Starting get note handler\");\n        const obsidian = await getObsidian(runtime);\n\n        try {\n            let path = \"\";\n            // Initialize or update state for context generation\n            // if (!state) {\n            //     state = (await runtime.composeState(message)) as State;\n            // } else {\n            //     state = await runtime.updateRecentMessageState(state);\n            // }\n\n            let currentState: State;\n            if (!state) {\n                currentState = (await runtime.composeState(message)) as State;\n            } else {\n                currentState = await runtime.updateRecentMessageState(state);\n            }\n\n            const context = composeContext({\n                state: currentState,\n                template: fileTemplate(message.content.text),\n            });\n\n            const noteContext = await generateObject({\n                runtime,\n                context,\n                modelClass: ModelClass.MEDIUM,\n                schema: noteSchema,\n                stop: [\"\\n\"]\n            }) as any;\n\n            if (!isValidNote(noteContext.object)) {\n                elizaLogger.error(\n                    \"A Note path is required. Use format: 'Get FOLDER/SUBFOLDER/Note Name.md' - \",\n                    noteContext.object\n                );\n\n                if (callback) {\n                    callback({\n                        text: `A Note path is required. Use format: 'Get FOLDER/SUBFOLDER/Note Name.md - ${noteContext.object}`,\n                        error: true,\n                    });\n                }\n\n                return false;\n            }\n\n            // Extract path from note context\n            path = noteContext.object.path\n\n            elizaLogger.info(`Fetching note at path: ${path}`);\n            const noteContent: NoteContent = await obsidian.getNote(path);\n\n            elizaLogger.info(`Successfully retrieved note: ${path}`);\n\n            if (callback) {\n                callback({\n                    text: noteContent.content,\n                    metadata: {\n                        path: noteContent.path,\n                    },\n                });\n            }\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error retrieving note:\", error);\n            if (callback) {\n                callback({\n                    text: `Error retrieving note: ${error.message}`,\n                    error: true,\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Get BLOG POSTS/How to Angel Invest, Part 1.md\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"GET_NOTE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Fetch BLOG POSTS/How to Angel Invest, Part 2.md\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"GET_NOTE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Read BLOG POSTS/STARTUPS/Build a Team that Ships.md\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"GET_NOTE\",\n                },\n            },\n        ],\n    ],\n};\n","import {\n    type Action,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    elizaLogger,\n    composeContext,\n    generateObject,\n    ModelClass\n} from \"@elizaos/core\";\nimport { fileSchema, isValidFile } from \"../types\";\nimport { getObsidian }  from \"../helper\";\nimport { fileTemplate } from \"../templates/file\";\n\nexport const readFileAction: Action = {\n    name: \"READ_FILE\",\n    similes: [\n        \"GET_FILE\",\n        \"FETCH_FILE\",\n        \"READ_FILE\",\n        \"RETRIEVE_FILE\",\n        \"LOAD_FILE\",\n        \"OPEN_FILE\",\n        \"ACCESS_FILE\",\n        \"VIEW_FILE\",\n        \"SHOW_FILE\",\n        \"READ\",\n    ],\n    description:\n        \"Retrieve and display the content of any file from Obsidian vault by path. Use format: 'Read FOLDER/SUBFOLDER/filename'\",\n    validate: async (runtime: IAgentRuntime) => {\n        try {\n            elizaLogger.debug(\"Validating Obsidian connection\");\n            const obsidian = await getObsidian(runtime);\n            await obsidian.connect();\n            elizaLogger.debug(\"Obsidian connection validated successfully\");\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Failed to validate Obsidian connection:\", error);\n            return false;\n        }\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: any,\n        callback?: HandlerCallback\n    ) => {\n        elizaLogger.info(\"Starting read file handler\");\n        const obsidian = await getObsidian(runtime);\n\n        try {\n            let path = \"\";\n            /*const text = message.content.text;\n\n            // Extract path from text like \"Read FOLDER/file.txt\"\n            if (text) {\n                const match = text.match(/^(?:Read\\s+)?(.+)$/i);\n                if (match) {\n                    path = match[1];\n                }\n            }\n\n            // Fallback to explicit path if provided\n            if (!path && message.content.path) {\n                path = message.content.path as string;\n            }\n\n            if (!path) {\n                throw new Error(\n                    \"File path is required. Use format: 'Read FOLDER/SUBFOLDER/filename'\"\n                );\n            }*/\n            // Initialize or update state for context generation\n            if (!state) {\n                state = (await runtime.composeState(message)) as State;\n            } else {\n                state = await runtime.updateRecentMessageState(state);\n            }\n\n            const context = composeContext({\n                state,\n                template: fileTemplate(message.content.text),\n            });\n\n            const fileContext = await generateObject({\n                runtime,\n                context,\n                modelClass: ModelClass.MEDIUM,\n                schema: fileSchema,\n                stop: [\"\\n\"]\n            }) as any;\n\n            if (!isValidFile(fileContext.object)) {\n                elizaLogger.error(\n                    \"A file path is required. Use format: 'Read FOLDER/SUBFOLDER/filename' - \",\n                    fileContext.object\n                );\n\n                if (callback) {\n                    callback({\n                        text: `A file path is required. Use format: 'Read FOLDER/SUBFOLDER/filename' - ${fileContext.object}`,\n                        error: true,\n                    });\n                }\n\n                return false;\n            }\n\n            // Extract path from note context\n            path = fileContext.object.path;\n\n            elizaLogger.info(`Reading file at path: ${path}`);\n            const fileContent: string = await obsidian.readFile(path);\n\n            elizaLogger.info(`Successfully read file: ${path}`);\n\n            if (callback) {\n                callback({\n                    text: fileContent,\n                    metadata: {\n                        path: path,\n                    },\n                });\n            }\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error reading file:\", error);\n            if (callback) {\n                callback({\n                    text: `Error reading file: ${error.message}`,\n                    error: true,\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Get DOCUMENTS/report.pdf\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"READ_FILE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Read PROJECTS/src/main.ts\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"READ_FILE\",\n                },\n            },\n        ],\n    ],\n};\n","import {\n    type Action,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    elizaLogger,\n    composeContext,\n    generateObject,\n    ModelClass\n} from \"@elizaos/core\";\nimport { fileSchema, isValidFile } from \"../types\";\nimport { getObsidian } from \"../helper\";\nimport { fileTemplate } from \"../templates/file\";\n\nexport const saveFileAction: Action = {\n    name: \"SAVE_FILE\",\n    similes: [\n        \"WRITE_FILE\",\n        \"CREATE_FILE\",\n        \"SAVE\",\n        \"STORE_FILE\",\n        \"PUT_FILE\",\n        \"WRITE_TO_FILE\",\n        \"CREATE_NEW_FILE\"\n    ],\n    description:\n        \"Create or update a file in the Obsidian vault. Use format: 'Save FOLDER/SUBFOLDER/filename with content: your_content'\",\n    validate: async (runtime: IAgentRuntime) => {\n        try {\n            elizaLogger.debug(\"Validating Obsidian connection\");\n            const obsidian = await getObsidian(runtime);\n            await obsidian.connect();\n            elizaLogger.debug(\"Obsidian connection validated successfully\");\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Failed to validate Obsidian connection:\", error);\n            return false;\n        }\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: any,\n        callback?: HandlerCallback\n    ) => {\n        elizaLogger.info(\"Starting save file handler\");\n        const obsidian = await getObsidian(runtime);\n\n        try {\n            // Initialize or update state for context generation\n            // if (!state) {\n            //     state = (await runtime.composeState(message)) as State;\n            // } else {\n            //     state = await runtime.updateRecentMessageState(state);\n            // }\n            let currentState: State;\n            if (!state) {\n                currentState = (await runtime.composeState(message)) as State;\n            } else {\n                currentState = await runtime.updateRecentMessageState(state);\n            }\n\n            const context = composeContext({\n                state: currentState,\n                template: fileTemplate(message.content.text),\n            });\n\n\n            const fileContext = await generateObject({\n                runtime,\n                context,\n                modelClass: ModelClass.MEDIUM,\n                schema: fileSchema,\n                stop: [\"\\n\"]\n            }) as any;\n\n            if (!isValidFile(fileContext.object)) {\n                elizaLogger.error(\n                    \"Invalid file information. Required: path and content. Format: 'Save FOLDER/SUBFOLDER/filename with content: your_content' - \",\n                    fileContext.object\n                );\n\n                if (callback) {\n                    callback({\n                        text: `Invalid file information. Required: path and content. Format: 'Save FOLDER/SUBFOLDER/filename with content: your_content' - ${fileContext.object}`,\n                        error: true,\n                    });\n                }\n                return false;\n            }\n\n            const { path, content } = fileContext.object;\n\n            if (!content) {\n                elizaLogger.error(\"File content is required for saving\");\n                if (callback) {\n                    callback({\n                        text: \"File content is required for saving\",\n                        error: true,\n                    });\n                }\n                return false;\n            }\n\n            elizaLogger.info(`Saving file at path: ${path}`);\n            // Note: Obsidian will create a new document at the path you have specified if such a document did not already exis\n            await obsidian.saveFile(path, content, true);\n            elizaLogger.info(`Successfully saved file: ${path}`);\n\n            if (callback) {\n                callback({\n                    text: `Successfully saved file: ${path}`,\n                    metadata: {\n                        path: path,\n                        operation: \"SAVE\",\n                        success: true\n                    },\n                });\n            }\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error saving file:\", error);\n            if (callback) {\n                callback({\n                    text: `Error saving file: ${error.message}`,\n                    error: true,\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Save DOCUMENTS/report.txt with content: This is a test report\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"SAVE_FILE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Create PROJECTS/src/config.json with content: { \\\"version\\\": \\\"1.0.0\\\" }\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"SAVE_FILE\",\n                },\n            },\n        ],\n    ],\n};\n","import {\n    type Action,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    elizaLogger,\n    composeContext,\n    generateObject,\n    ModelClass\n} from \"@elizaos/core\";\nimport { fileSchema, isValidFile } from \"../types\";\nimport { getObsidian } from \"../helper\";\nimport { fileTemplate } from \"../templates/file\";\n\nexport const openFileAction: Action = {\n    name: \"OPEN_FILE\",\n    similes: [\n        \"OPEN\",\n        \"LAUNCH_FILE\",\n        \"DISPLAY_FILE\",\n        \"SHOW_FILE\",\n        \"VIEW_FILE\"\n    ],\n    description:\n        \"Open a file in the Obsidian interface. Use format: 'Open FOLDER/SUBFOLDER/filename'\",\n    validate: async (runtime: IAgentRuntime) => {\n        try {\n            elizaLogger.debug(\"Validating Obsidian connection\");\n            const obsidian = await getObsidian(runtime);\n            await obsidian.connect();\n            elizaLogger.debug(\"Obsidian connection validated successfully\");\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Failed to validate Obsidian connection:\", error);\n            return false;\n        }\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: any,\n        callback?: HandlerCallback\n    ) => {\n        elizaLogger.info(\"Starting open file handler\");\n        const obsidian = await getObsidian(runtime);\n\n        try {\n            // Initialize or update state for context generation\n            // if (!state) {\n            //     state = (await runtime.composeState(message)) as State;\n            // } else {\n            //     state = await runtime.updateRecentMessageState(state);\n            // }\n            let currentState: State;\n            if (!state) {\n                currentState = (await runtime.composeState(message)) as State;\n            } else {\n                currentState = await runtime.updateRecentMessageState(state);\n            }\n\n            const context = composeContext({\n                state: currentState,\n                template: fileTemplate(message.content.text),\n            });\n\n\n            const fileContext = await generateObject({\n                runtime,\n                context,\n                modelClass: ModelClass.MEDIUM,\n                schema: fileSchema,\n                stop: [\"\\n\"]\n            }) as any;\n\n            if (!isValidFile(fileContext.object)) {\n                elizaLogger.error(\n                    \"Invalid file path. Format: 'Open FOLDER/SUBFOLDER/filename' - \",\n                    fileContext.object\n                );\n\n                if (callback) {\n                    callback({\n                        text: `Invalid file path. Format: 'Open FOLDER/SUBFOLDER/filename' - ${fileContext.object}`,\n                        error: true,\n                    });\n                }\n                return false;\n            }\n\n            const { path } = fileContext.object;\n\n            elizaLogger.info(`Opening file at path: ${path}`);\n            await obsidian.openFile(path);\n            elizaLogger.info(`Successfully opened file: ${path}`);\n\n            if (callback) {\n                callback({\n                    text: `Successfully opened file: ${path}`,\n                    metadata: {\n                        path: path,\n                        operation: \"OPEN\",\n                        success: true\n                    },\n                });\n            }\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error opening file:\", error);\n            if (callback) {\n                callback({\n                    text: `Error opening file: ${error.message}`,\n                    error: true,\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Open DOCUMENTS/report.txt\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"OPEN_FILE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Show PROJECTS/src/config.json\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"OPEN_FILE\",\n                },\n            },\n        ],\n    ],\n};","import {\n    type Action,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    elizaLogger,\n    composeContext,\n    generateObject,\n    ModelClass\n} from \"@elizaos/core\";\nimport { fileSchema, isValidFile } from \"../types\";\nimport { getObsidian } from \"../helper\";\nimport { fileTemplate } from \"../templates/file\";\n\n\n// Add at the top with other imports\ninterface UpdateFileOptions {\n    path?: string;\n    content?: string;\n    createIfNotExists?: boolean;\n}\n\nexport const updateFileAction: Action = {\n    name: \"UPDATE_FILE\",\n    similes: [\n        \"PATCH_FILE\",\n        \"MODIFY_FILE\",\n        \"UPDATE\",\n        \"PATCH\",\n        \"EDIT_FILE\",\n        \"CHANGE_FILE\"\n    ],\n    description:\n        \"Update an existing file in the Obsidian vault. Use format: 'Update FOLDER/SUBFOLDER/filename with content: your_content'\",\n    validate: async (runtime: IAgentRuntime) => {\n        try {\n            elizaLogger.debug(\"Validating Obsidian connection\");\n            const obsidian = await getObsidian(runtime);\n            await obsidian.connect();\n            elizaLogger.debug(\"Obsidian connection validated successfully\");\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Failed to validate Obsidian connection:\", error);\n            return false;\n        }\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: UpdateFileOptions,\n        callback?: HandlerCallback\n    ) => {\n        elizaLogger.info(\"Starting update file handler\");\n        const obsidian = await getObsidian(runtime);\n\n        try {\n            // Initialize or update state for context generation\n            // if (!state) {\n            //     state = (await runtime.composeState(message)) as State;\n            // } else {\n            //     state = await runtime.updateRecentMessageState(state);\n            // }\n\n            // Initialize or update state for context generation\n            let currentState: State;\n            if (!state) {\n                currentState = (await runtime.composeState(message)) as State;\n            } else {\n                currentState = await runtime.updateRecentMessageState(state);\n            }\n\n            const context = composeContext({\n                state: currentState,\n                template: fileTemplate(message.content.text),\n            });\n\n            const fileContext = await generateObject({\n                runtime,\n                context,\n                modelClass: ModelClass.MEDIUM,\n                schema: fileSchema,\n                stop: [\"\\n\"]\n            }) as any;\n\n            if (!isValidFile(fileContext.object)) {\n                elizaLogger.error(\n                    \"Invalid file information. Required: path and content. Format: 'Update FOLDER/SUBFOLDER/filename with content: your_content' - \",\n                    fileContext.object\n                );\n\n                if (callback) {\n                    callback({\n                        text: `Invalid file information. Required: path and content. Format: 'Update FOLDER/SUBFOLDER/filename with content: your_content' - ${fileContext.object}`,\n                        error: true,\n                    });\n                }\n                return false;\n            }\n\n            const { path, content } = fileContext.object;\n\n            if (!content) {\n                elizaLogger.error(\"File content is required for updating\");\n                if (callback) {\n                    callback({\n                        text: \"File content is required for updating\",\n                        error: true,\n                    });\n                }\n                return false;\n            }\n\n            elizaLogger.info(`Updating file at path: ${path}`);\n            // Note: patchFile will only update existing files, it will not create new ones\n            await obsidian.patchFile(path, content);\n            elizaLogger.info(`Successfully updated file: ${path}`);\n\n            if (callback) {\n                callback({\n                    text: `Successfully updated file: ${path}`,\n                    metadata: {\n                        path: path,\n                        operation: \"UPDATE\",\n                        success: true\n                    },\n                });\n            }\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error updating file:\", error);\n            if (callback) {\n                callback({\n                    text: `Error updating file: ${error.message}`,\n                    error: true,\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Update DOCUMENTS/report.txt with content: This is an updated report\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"UPDATE_FILE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Patch PROJECTS/src/config.json with content: { \\\"version\\\": \\\"2.0.0\\\" }\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"{{responseData}}\",\n                    action: \"UPDATE_FILE\",\n                },\n            },\n        ],\n    ],\n};","import { searchAction } from \"./actions/search\";\nimport { listNotesAction } from \"./actions/listNotes\";\nimport { listAllFilesAction } from \"./actions/vault\";\nimport { listDirectoryAction } from \"./actions/vaultDirectory\";\nimport { createKnowledgeAction } from \"./actions/createKnowledge\";\nimport { noteTraversalAction } from \"./actions/noteTraversal\";\nimport {\n    getActiveNoteAction,\n    summarizeActiveNoteAction,\n} from \"./actions/activeNote\";\nimport { getNoteAction } from \"./actions/note\";\nimport { readFileAction } from \"./actions/file\";\nimport { saveFileAction } from \"./actions/saveFile\";\nimport { openFileAction } from \"./actions/openFile\";\nimport { updateFileAction } from \"./actions/updateFile\";\n\nexport const obsidianPlugin = {\n    name: \"obsidian\",\n    description: \"Integration with Obsidian vault using Omnisearch / Deep traversal search and memoryknowledge base\",\n    actions: [\n        searchAction,\n        listNotesAction,\n        listAllFilesAction,\n        listDirectoryAction,\n        summarizeActiveNoteAction,\n        getActiveNoteAction,\n        getNoteAction,\n        readFileAction,\n        createKnowledgeAction,\n        noteTraversalAction,\n        saveFileAction,\n        openFileAction,\n        updateFileAction\n    ],\n    evaluators: [],\n    services: [],\n    providers: [],\n};\n\nexport default obsidianPlugin;\n"],"mappings":"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","names":["elizaLogger","elizaLogger","stringToUuid","response","results","z","z","elizaLogger","stringToUuid","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","files","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","composeContext","generateObject","ModelClass","elizaLogger","composeContext","generateObject","ModelClass","hierarchy","elizaLogger","composeContext","ModelClass","elizaLogger","composeContext","ModelClass","elizaLogger","composeContext","generateObject","ModelClass","elizaLogger","composeContext","generateObject","ModelClass","elizaLogger","composeContext","generateObject","ModelClass","elizaLogger","composeContext","generateObject","ModelClass","elizaLogger","composeContext","generateObject","ModelClass","elizaLogger","composeContext","generateObject","ModelClass","elizaLogger","composeContext","generateObject","ModelClass","elizaLogger","composeContext","generateObject","ModelClass","elizaLogger","composeContext","generateObject","ModelClass","elizaLogger","composeContext","generateObject","ModelClass"]}